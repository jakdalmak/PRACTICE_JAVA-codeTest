class Solution {
    public int solution(int[][] lines) {
        // imos 법을 사용해보자!
        // imos 법이란? => https://driip.me/65d9b58c-bf02-44bf-8fba-54d394ed21e0 참고.
        
        // 간단히 말해서, imos 법 없이 해당 문제를 풀려면
        // 배열을 하나 만들고, lines의 각 요소 범위 내에 해당하는 인덱스를 순회하며 각 순회 범위마다 1을 모두 더하기.
        // 배열을 순회하며, 범위 내의 2 이상의 값을 지니는 요소들을 카운트. 카운트 결과 값이 리턴 값!
        /* 이 부분 오류. 굳이 배열 만들 필요 없이 별도 카운트 값 만으로 작성 가능.
         * 즉, imos의 사용 없이 그냥 일반적인 단일 for문으로도 풀 수 있는 문제이다..
         */
        
        
        // 하지만 imos 법은, 각 선이 시작하는 배열의 인덱스에 +1을, 종료되는 인덱스에 -1을 수행함.
        // 이후 해당 배열을 순회하며 +1을 만날 때마다 해당 인덱스를 포함하여 이후에 만나는 모든 인덱스마다 +1을 수행.
        // 또 +1을 만나면, 더하던 값에 +1을 한 값을 배열에 더하기.
        // -1을 만나면, 더하던 값에 -1을 한 값을 배열에 더하기...
        
        // 이를 통해, 한 번의 순회만으로 누적합을 수행하는 것이 imos 법의 포인트이다.
        
        // 그런데.. 음수 범위의 인덱스를 어떻게 표기하지?
        // => 그냥 더해~
        
        
        int[] LINE = new int[201];
        // 음수 대비하여 값에 +100을 수행할 예정. 이로 인해 0 ~ 200까지의 범위 필요하므로, 201로 사이즈 맞춤.
        
        /* imos 위한 +1, -1 값 설정 */
        for(int i = 0; i < lines.length; i++) {
            // java에서 배열의 기본 값은 0으로 설정되어있음.
            LINE[lines[i][0] + 100] += 1;
            LINE[lines[i][1] + 100] += -1;
        }
        
        
        /* imos 누적합 실제 수행 위한 순회 */
        // 중요! 본 문제는 '선이 겹친 길이'를 구하는 것이다.
        // 점이 겹쳐있는 경우는 구하지 않음.
        // 단, 점이 겹쳐있어 한번에 1 또는 -1보다 큰 값을 표기해야 하는 경우는 있을수도 있다.
        // 이 점에 유의할 것.
        int plus = 0;
        int answer = 0;
        
        for(int i = 0; i < LINE.length; i++) {
            if(LINE[i] >= 1) {
                plus += LINE[i];
            }
            if(LINE[i] <= -1) {
                plus += LINE[i];
            }
            
            if(plus >= 2) answer++; 
            // 현재 루프에서 plus가 2 이상인 경우, 2개 이상의 선이 겹쳐있는 것이므로 카운팅 미리 수행.
        }
        
        
        
        
        return answer;
    }
}